<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Jack Taylor" />


<title>Higher Level Controls (control_for_map)</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Higher Level Controls (control_for_map)</h1>
<h4 class="author">Jack Taylor</h4>



<p>The <code>control_for()</code> function works well when your variable is 1-dimensional, with a single value for each word, as it is for variables like Length, Frequency or Concreteness. Things become slightly trickier, however, when controlling for distance or similarity values, which can be calculated for each unique combination of words (i.e.Â <span class="math inline">\(n^2\)</span> values). One easy solution is to use <code>control_for_map()</code> to pass a function which should be used to calculate the value between any two words. Simple examples for controlling for orthographic and phonological similarity are available in the <a href="https://jackedtaylor.github.io/LexOPSdocs/advanced-stimulus-generation.html#map-functions-as-controls">package bookdown site</a>. This vignette demonstrates how to build your own function for <code>control_for_map()</code>, which in this example controls for semantic similarity.</p>
<div id="packages" class="section level1">
<h1>Packages</h1>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">library</span>(readr)</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">library</span>(dplyr)</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">library</span>(LexOPS)</a></code></pre></div>
</div>
<div id="importing-datsets" class="section level1">
<h1>Importing Datsets</h1>
<p>The word pair norms come from <a href="https://doomlab.shinyapps.io/double_words/">Erin Buchanan and colleagues</a>. This dataset indexes semantic similarity between cues and targets. Alternative sources of semantic association/relatedness values include the <a href="https://smallworldofwords.org/en/project">Small World of Words</a>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" title="1">pairs &lt;-<span class="st"> </span>readr<span class="op">::</span><span class="kw">read_csv</span>(<span class="st">&quot;https://media.githubusercontent.com/media/doomlab/shiny-server/master/wn_double/double_words.csv&quot;</span>)</a></code></pre></div>
<pre><code>## Parsed with column specification:
## cols(
##   CUE = col_character(),
##   TARGET = col_character(),
##   root = col_double(),
##   raw = col_double(),
##   affix = col_double(),
##   cosine2013 = col_double(),
##   jcn = col_double(),
##   lsa = col_double(),
##   fsg = col_double(),
##   bsg = col_double()
## )</code></pre>
</div>
<div id="creating-the-semantic-similarity-function" class="section level1">
<h1>Creating the Semantic Similarity Function</h1>
<p>The function we create should index the similarity between <span class="math inline">\(n\)</span> matches (in a vector) and a target word (as a single string). The result should be a vector of values of length <span class="math inline">\(n\)</span>, in the same order as the matches. Using the <code>pairs</code> tibble, we can use some <code>dplyr</code> manipulation to return the required values as a vector. This function returns the <code>root</code> values, indexing the cosine of two wordsâ semantic overlap for root words (see <a href="https://doomlab.shinyapps.io/double_words/">here</a> for more details).</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" title="1">sem_matches &lt;-<span class="st"> </span><span class="cf">function</span>(matches, target) {</a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="co"># for speed, return N ones if possible</span></a>
<a class="sourceLine" id="cb4-3" title="3">  <span class="cf">if</span> (<span class="kw">all</span>(matches<span class="op">==</span>target)) <span class="kw">return</span>(<span class="kw">rep</span>(<span class="dv">1</span>, <span class="kw">length</span>(matches)))</a>
<a class="sourceLine" id="cb4-4" title="4">  <span class="co"># find each match-target association value</span></a>
<a class="sourceLine" id="cb4-5" title="5">  <span class="kw">tibble</span>(<span class="dt">CUE =</span> matches, <span class="dt">TARGET =</span> target) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="st">    </span><span class="kw">full_join</span>(pairs, <span class="dt">by=</span><span class="kw">c</span>(<span class="st">&quot;CUE&quot;</span>, <span class="st">&quot;TARGET&quot;</span>)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="st">    </span><span class="kw">filter</span>(TARGET <span class="op">==</span><span class="st"> </span>target <span class="op">&amp;</span><span class="st"> </span>CUE <span class="op">%in%</span><span class="st"> </span>matches) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="st">    </span><span class="kw">pull</span>(root)</a>
<a class="sourceLine" id="cb4-9" title="9">}</a></code></pre></div>
<p>Letâs test the function on some example match-target combinations.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" title="1"><span class="co"># should return 1</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">sem_matches</span>(<span class="st">&quot;yellow&quot;</span>, <span class="st">&quot;yellow&quot;</span>)</a></code></pre></div>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" title="1"><span class="co"># should return 3 values: 1 if identical, 0&lt;x&lt;1 if value present, NA if missing</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">sem_matches</span>(<span class="kw">c</span>(<span class="st">&quot;yellow&quot;</span>, <span class="st">&quot;sun&quot;</span>, <span class="st">&quot;leaf&quot;</span>), <span class="st">&quot;yellow&quot;</span>)</a></code></pre></div>
<pre><code>## [1] 1.0000000 0.2458601        NA</code></pre>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" title="1"><span class="co"># would return N=nrow(lexops) values (mostly NA) of similarity to &quot;yellow&quot;</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="co"># sem_matches(lexops$string, &quot;yellow&quot;)</span></a></code></pre></div>
</div>
<div id="generating-stimuli" class="section level1">
<h1>Generating Stimuli</h1>
<p>We can now generate stimuli controlling for semantic similarity. If we want to generate words which are highly semantically related, we can control for semantic relatedness of <span class="math inline">\(&gt;=0.5\)</span> cosine similarity to an iterationâs match null. Since a match null is placed at 0, and will have a similarity of 1 to itself, we set the <code>control_for_map()</code> tolerance to <code>-0.5:0</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" title="1"><span class="co"># speed up by removing unusable word pairs from pairs</span></a>
<a class="sourceLine" id="cb10-2" title="2">pairs &lt;-<span class="st"> </span><span class="kw">filter</span>(pairs, root<span class="op">&gt;=</span><span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb10-3" title="3"></a>
<a class="sourceLine" id="cb10-4" title="4">stim &lt;-<span class="st"> </span>lexops <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="st">  </span><span class="co"># speed up by removing strings unknown to pairs df</span></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="st">  </span>dplyr<span class="op">::</span><span class="kw">filter</span>(string <span class="op">%in%</span><span class="st"> </span>pairs<span class="op">$</span>CUE) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb10-7" title="7"><span class="st">  </span><span class="co"># create a random 2-level split</span></a>
<a class="sourceLine" id="cb10-8" title="8"><span class="st">  </span><span class="kw">split_random</span>(<span class="dv">2</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb10-9" title="9"><span class="st">  </span><span class="co"># control for semantic similarity</span></a>
<a class="sourceLine" id="cb10-10" title="10"><span class="st">  </span><span class="kw">control_for_map</span>(sem_matches, string, <span class="fl">-0.5</span><span class="op">:</span><span class="dv">0</span>, <span class="dt">name =</span> <span class="st">&quot;root_cosine&quot;</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb10-11" title="11"><span class="st">  </span><span class="co"># control for other values</span></a>
<a class="sourceLine" id="cb10-12" title="12"><span class="st">  </span><span class="kw">control_for</span>(Length, <span class="dv">0</span><span class="op">:</span><span class="dv">0</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb10-13" title="13"><span class="st">  </span><span class="kw">control_for</span>(PoS.SUBTLEX_UK) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb10-14" title="14"><span class="st">  </span><span class="kw">control_for</span>(Zipf.SUBTLEX_UK, <span class="fl">-0.2</span><span class="op">:</span><span class="fl">0.2</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb10-15" title="15"><span class="st">  </span><span class="co"># generate 20 items per factorial cell (40 total)</span></a>
<a class="sourceLine" id="cb10-16" title="16"><span class="st">  </span><span class="kw">generate</span>(<span class="dv">20</span>)</a></code></pre></div>
<pre><code>## Generated 2/20 (10%). 4 total iterations, 0.50 success rate.
## Generated 4/20 (20%). 189 total iterations, 0.02 success rate.
## Generated 6/20 (30%). 323 total iterations, 0.02 success rate.
## Generated 8/20 (40%). 375 total iterations, 0.02 success rate.
## Generated 10/20 (50%). 486 total iterations, 0.02 success rate.
## Generated 12/20 (60%). 530 total iterations, 0.02 success rate.
## Generated 14/20 (70%). 795 total iterations, 0.02 success rate.
## Generated 16/20 (80%). 879 total iterations, 0.02 success rate.
## Generated 18/20 (90%). 1097 total iterations, 0.02 success rate.
## Generated 20/20 (100%). 1644 total iterations, 0.01 success rate.</code></pre>
<p>Here are our 20 items per factorial cell, matched by Semantic Similarity, Length, Part of Speech, and Frequency.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">print</span>(stim)</a></code></pre></div>
<pre><code>##    item_nr        A1        A2 match_null
## 1        1    cereal    barley         A1
## 2        2   seagull   buzzard         A1
## 3        3     trout     squid         A1
## 4        4      goat      calf         A1
## 5        5       her       she         A2
## 6        6    bright    yellow         A2
## 7        7 blueberry cranberry         A2
## 8        8     viola     bugle         A1
## 9        9   parsley   lettuce         A1
## 10      10  contract  conflict         A1
## 11      11     canal     shore         A2
## 12      12      gone      move         A2
## 13      13      leaf      seed         A2
## 14      14  schedule  homework         A1
## 15      15     pants     shirt         A2
## 16      16      pull      push         A2
## 17      17      jane      mary         A2
## 18      18     flame     torch         A1
## 19      19     pound     punch         A2
## 20      20     woman     girls         A1</code></pre>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
